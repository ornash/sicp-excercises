#+TITLE: Notes on Structure and Interpretation of Computer Programs
#+STARTUP: indent
[[./sicp.html][HTML Export]]
[[https://github.com/ornash/book-notes/blob/master/sicp.org][Github Page]]


* Chapter 1 : Building Abstractions with Procedures
** Computational Process
Computational processes are abstract beings that inhabit computers. As they evolve, processes manipulate other abstract
things called data. The evolution of a process is directed by a pattern of rules called a program. People create
programs to direct processes.

** Elements of Programming
Every powerful language has three mechanisms for expressing processes:
1. *primitive expressions*, which represent the simplest entities the language is concerned with,
2. *means of combination*, by which compound elements are built from simple ones, and
3. *means of abstraction*, by which compound elements can be named and manipulated as units.

** Procedure/Program Application/Evaluation
A substition model is used for procedure application. There are two evalution methods for procedure application:
1. *Applicative-order evaluation*: evaluate the arguments and then apply. An argument is evaluated only once but that
   evaluation is going to be wasteful if the argument isn't used. Scheme uses applicative-order evaluation.
2. *Normal-order evaluation*: fully expand and then reduce/evaluate i.e. obtain expression involving only primitives and
   then evaluate. An argument isn't evaluated until it is used but it might be evaluated more than once after full expansion.

Check out exercise [[https://github.com/ornash/sicp-excercises/tree/master/chapter-1/20-applicative-vs-normal][1.20]] to understand how this choice affects evaluation.

** Procedures and the Processes They Generate
We now know the elements of programming, but that is not enough to say that we know how to program. In order to become
expert programmer, we must learn to visualize the processes generated by various types of procedures. We must also learn
to calculate the rates at which the procedure consumes the computational resources of time and space.

*** Recursive Procedures
Evaluate and visualize the processes generated by following *recursive procedures* in terms of time and space.
#+BEGIN_SRC scheme
;;Recursive procedure that generates *recursive* process.
(define (factorial n)
  (if (= n 1)
    1
    (* n (factorial (- n 1)))))

;;Recursive procedure that generates *iterative* process.
(define (factorial-iter n)
  (define (iter product counter)
    (if (> counter n)
      product
      (iter (* counter product)
            (+ counter 1))))
  (iter 1 1))  
#+END_SRC

When we consider the "shapes" of the two processes, we see that they evolve quite differently. One grows and shrinks
while other is lean. Carrying out the *recursive* process requires that the interpreter keep track of some *hidden*
information and operations to be performed later on. On the other hand, carrying out the *iterative* process does not
require processing any hidden information, its state can be summarized by fixed number of state variables in the
procedure.

The implementation that generates iterative process is called as *tail recursive* implementation. In tail recursive
implementation the last statement is a call to recursive procedure itself with no work left to be performed in current
procedure call; therefore, compiler can optimize such call by replacing current stack frame instead of creating a new
one.

*** Tree Recursion
Evaluate and visualize the processes generated by following *recursive procedures* in terms of time and space.
#+BEGIN_SRC scheme
;;Recursive procedure that generates *tree recursive* process.
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1)) (fib (- n 2))))
  ))

;;Recursive procedure that generates *iterative* process.
(define (fib-iter n)
  (define (iter a b count)
    (cond ((= n 0) 0)
          ((= n 1) 1)
          ((= count n) a)
          (else (iter (+ a b) a (+ count 1)))))
   (iter 1 0 1))
#+END_SRC

Tree recursion is a powerful tool to operate on hierarchically structured data.

*** Decomposition
Functional procedures encourage reuse because every computation unit is defined as a function which can be used somewhere
else. Decomposition into units also helps transform one implementation into other quickly.

*** Notes
- Functional programming makes you think in terms of functions/tasks and not in terms of data/elements e.g. Compare the
  difference in implementation of the following in imperative programming. Use wishful thinking and abstraction to
  program better and faster.
#+BEGIN_SRC scheme
(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
  (cond ((> (square test-divisor) n) n)
        ((divides? test-divisor n) test-divisor)
        (else (find-divisor n (+ test-divisor 1)))))

(define (divides? denom numer)
  (= (remainder numer denom) 0))
#+END_SRC
- Be careful of recursive procedures, subtle changes in code can result in huge difference in time
  complexity. e.g. Check exercise [[./chapter-1/22-search-primes/22-search-primes.scm][1.25]] and [[./chapter-1/22-search-primes/22-search-primes.scm][1.26]].
** Formulating Abstractions with Higher Order Procedures
Procedures that manipulate procedures are called higher-order procedures i.e. procedures that can accept procedures as
arguments or return procedures as values. As shown below higher-order procedures permit us to manipulate general methods
to create further abstractions.

*** Procedure as Argument
#+BEGIN_SRC scheme
(define (sum operation a next b)
  (if (> a b)
      0
      (+ (operation a)
         (sum operation (next a) next b))))

(define (inc n) (+ n 1))

(define (cube x) (* x x x))

(define (sum-cubes a b)
  (sum cube a inc b))

(define (identity x) x)

(define (sum-integers a b)
  (sum identity a inc b))
#+END_SRC

*** Constructing Procedures Using Lambda
(lambda (<formal-parameters>) <body>)

#+BEGIN_SRC scheme
(lambda (x) (+ x 1))

(define (sum-cubes a b)
  (sum cube a (lambda (x) (+ x 1)) b))
#+END_SRC

- Lambda function's body is usually defined in terms existing functions.
- Lambda function can itself define and use other lambda functions in its body.
- Lambda function can itself expect other functions as parameters and use them in its body.
- Functions can define lambdas on the fly and apply them.
- Functions can define lambdas on the fly and pass them as arguments.
- When a function receives a lambda function as parameter it gets a name and that named function can itself be applied
  and evaluated.
*** Using let To Create Local Variable
Let allows one to bind variables as locally as possible to where they are to be used. The general form of a let
expression is

(let ((<var1> <exp1>)
      (<var2> <exp2>)
      ...
      (<varN> <expN>))
  <body>)
  
which can be thought of as saying

let <var1> have the value <exp1> and
    <var2> have the value <exp2> and
    ...
    <varN> have the value <expN>
  in <body>
#+BEGIN_SRC scheme
(define (f x y)
  (let ((a (+ 1 (* x y)))
        (b (- 1 y)))
    (+ (* x (square a))
       (* y b)
       (* a b))))
#+END_SRC

*** Procedures as Returned Values
Procedures can be returned using lambda as follows

#+BEGIN_SRC scheme
(define (get-average-reduction-function-using-function f)
  (lambda (x) 
    (average x (f x))))

((get-average-reduction-function-using-function square) 10)

;;This returns 55, which is the average of 10 and (square 10)
#+END_SRC

*** Abstraction and First Class Procedures
We know that compound procedures are a crucial abstraction mechanism, because they permit us to express general methods
of computing as explicit elements in our programming language e.g. (* x x x) can be represented with a general method
called (cube x). Higher-order procedures permit us to manipulate these general methods to create further abstractions.

As programmers, we should be alert to opportunities to identify the underlying abstractions in our programs and to build
upon them and generalize them to create more powerful abstractions. This is not to say that one should always write
programs in the most abstract way possible; expert programmers know how to choose the level of abstraction appropriate
to their task. But it is important to be able to think in terms of these abstractions, so that we can be ready to apply
them in new contexts. The significance of higher-order procedures is that they enable us to represent these abstractions
explicitly as elements in our programming language, so that they can be handled just like other computational elements.

In general, programming languages impose restrictions on the ways in which computational elements can be
manipulated. Elements with the fewest restrictions are said to have first-class status. Some of the “rights and
privileges” of first-class elements are:

1. They may be named by variables.
2. They may be passed as arguments to procedures.
3. They may be returned as the results of procedures.
4. They may be included in data structures.

*Scheme/Lisp, unlike other common programming languages, awards procedures full first-class status.* This poses
challenges for efficient implementation, but the resulting gain in expressive power is enormous. Chapter 4 highlights
these challenges and provides solutions to deal with them.

*** Notes
- Higher-order procedures don't just allow us to manipulate general methods of computation, they also allow us to reason
  in terms of those general methods thereby enhancing the power of programming langauge to express complex ideas as well
  as the power of programmer to reason about those complex ideas.
- When you create abstractions keep in mind that the deeper they are the more difficult they are for the reader to
  understand. Keep them shallow if possible.
- The goal of writing abstractions is to try to arrive at a state where the abstraction can be used as: f(g(h(x),y))
  i.e. a chain of function calls.
- With practice, you should be able to traverse up and down the call tree to manipulate and define the right
  abstraction.
- As the number of higher order functions in the call tree increase, it becomes difficult to keep track of variables so
  ensure that you always use good procedure names and unique variable names so that the code makes sense in
  future. e.g. check [[./chapter-1/42-compose/42-compose.scm][1.46]].
** Miscellaneous
*** Writing Recursive Programs
- Think in terms of smallest/simplest units of computation that is already available or you can achieve, then assemble
  small units to build larger units. Start with the base case and build up.
- Express your computation in as less words as possible, less code leads to less bugs.
- Do not think of simplifying your recursive program to generate an iterative process instead of recursive process
  immediately. First write a program that generates recusive and then improve it so that it generates iterative
  process.
*** Advantages of Recursive Programs
- Compare the amount of code written for recursive/functional programs with equivalent code in procedural programming,
  *When you think differently, you write less code.* 
- You are able to write full fledged programs by only knowing about few core concepts.
- It forces you to write code in small units which ultimately help identify patterns.
- Identified patterns can further be used to define higher-order procedures.


* Chapter 2 : Building Abstractions with Data
Last chapter focused on building abstractions by combining procedures to form compound procedures. This chapter will
focus on another key aspect of building abstractions which involves combining data objects to form compound data.

Why do we want compound data in a programming language?
- For the same reasons that we want compound procedures:
  - to elevate the conceptual level at which we can design our programs,
  - to increase the modularity of our designs,
  - and to enhance the expressive power of our language.

Notes:
- The primary goal of a programming language is to allow the programmer to think better. If the programmer thinks better
  the code will automatically be better. Similary, for software, it shold allow its user to think and therefore work
  better.

** Data Abstraction
The general technique of isolating the parts of a program that deal with how data objects are *represented* from the
parts of a program that deal with how data objects are *used* is called data abstraction.

Programming languages usually provide some primitive data objects and operations that can be used to form compound
data. But *compound data* can also be formed using just procedures which blurs the distinction between data and
procedures. Both should be treated as mechanisms to achieve abstraction.

*** Data Abstraction
- Data abstraction is a methodology that enables us to isolate how a compound data object is used from the details of
  how it is constructed from more primitive data objects.
- Structure the programs that are going to use compound data so that they operate on *abstract data*.
- At the same time, define a *concrete representation* that is independent of its usage.
- The interface between these two parts of our system will be a set of procedures, called *selectors and constructors*,
  that implement the *abstract data* in terms of the *concrete representation*.
- e.g. an implementation of rational numbers.
#+BEGIN_SRC scheme
(define (make-rat n d) (cons n d))
(define (numer x) (car x))
(define (denom x) (cdr x))
#+END_SRC
- An alternative approach that can be implemented later. Data abstraction allows changing it because users are only
  aware of the constructor make-rat, and selectors numer and denom.
#+BEGIN_SRC scheme
(define (make-rat n d)
  (let ((g (gcd n d)))
    (cons (/ n g) 
          (/ d g))))
(define (numer x) (car x))
(define (denom x) (cdr x))
#+END_SRC

*** Abstraction Barriers
- Data abstraction forms levels and procedures at each level are the interfaces that define the *abstraction barriers*
  and connect the different levels.
- The data-abstraction methodology gives us a way to defer some implementation/representation decisions without losing
  the ability to make progress on the rest of the system.
- e.g. we can change above implementation later as follows:
#+BEGIN_SRC scheme
(define (make-rat n d)
  (cons n d))

(define (numer x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (car x) g)))

(define (denom x)
  (let ((g (gcd (car x) (cdr x))))
    (/ (cdr x) g)))
#+END_SRC

*** What Is Meant by Data?
- It is not enough to say “whatever is implemented by the given selectors and constructors.”
- We can think of data as defined by *some collection of selectors and constructors*, *together with specified
  conditions that these procedures must fulfill in order to be a valid representation*.
- For e.g. If we construct a rational number x from a pair of integers n and d, we need to guarantee that extracting the
  numer and the denom of x and dividing them should yield the same result as dividing n by d.
- An alternative implementation of "cons" could be:
#+BEGIN_SRC scheme
(define (cons x y)
  (define (dispatch m)
    (cond ((= m 0) x)
          ((= m 1) y)
          (else 
           (error "Argument not 0 or 1:
                   CONS" m))))
  dispatch)

(define (car z) (z 0))
(define (cdr z) (z 1))
#+END_SRC
- Our implementation of rational numbers is unaffected by this change to "cons".
- Note that this blurs the line between procedures and data. Thus, what matters is whether the constructors and
  selectors satisfy the conditions of the data abstraction not how they are implemented or represented.
- The data representation optimization decisions can be pushed to a later time if required.


** Hierarchical Data and the Closure Property
The ability to create pairs whose elements are pairs is the essence of list structure's importance as a representational
tool.  We refer to this ability as the "closure property" of 'cons'.

Closure is the key to power in any means of combination because it permits us to create "hierarchical"
structures--structures made up of parts, which themselves are made up of parts, and so on.

*** Representing Sequences
Scheme has list operation to represent sequences.

(list <A_1> <A_2> ... <A_N>)

is equivalent to

(cons <A_1> (cons <A_2> (cons ... (cons <A_N> nil) ...)))

**** List Operations
"cdr down and cons up"
#+BEGIN_SRC scheme
(define (length items)
    (if (null? items)
    0
    (+ 1 (length (cdr items)))))

(define (append list1 list2)
    (if (null? list1)
    list2
    (cons (car list1) (append (cdr list1) list2))))
#+END_SRC

**** Mapping Over Lists
#+BEGIN_SRC scheme
(define (scale-list items factor)
    (if (null? items)
        nil
        (cons (* (car items) factor)
              (scale-list (cdr items) factor))))
#+END_SRC

We can keep doing "cdr down and cons up" but we can abstract this general idea and capture it as a common pattern
expressed as a higher-order procedure called "map".

#+BEGIN_SRC scheme
(define (map proc items)
    (if (null? items)
        nil
        (cons (proc (car items))
              (map proc (cdr items)))))

(define (scale-list items factor)
    (map (lambda (x) (* x factor))
         items))
#+END_SRC

'Map' is an important construct, not only because it captures a common pattern, but because it establishes a higher
level of  abstraction in dealing with lists.  In the original definition of 'scale-list', the recursive structure of the
program draws attention to the element-by-element processing of the list.  Defining 'scale-list' in terms of 'map'
suppresses that level of detail and emphasizes that scaling transforms a list of elements to a list of results.  The
difference between the two definitions is not that the computer is performing a different process (it isn't) but that we
think about the process differently.  In effect, 'map' helps establish an abstraction barrier.

*** Hierarchical Structures
*** Sequences as Conventional Interfaces
*** Example: A Picture Language

* Miscellaneous

* References
- https://mitpress.mit.edu/sites/default/files/sicp/index.html
- https://sarabander.github.io/sicp/html/index.xhtml
- http://zv.github.io/sicp-in-texinfo
- https://xuanji.appspot.com/isicp/index.html
- https://www.neilvandyke.org/sicp-texi/
- https://github.com/webframp/sicp-info

* SICP Info
** Install
#+BEGIN_SRC bash
mv ~/Downloads/sicp.info /usr/local/share/info/
install-info /usr/local/share/info/sicp.info --dir-file="/usr/local/share/info/dir"
#+END_SRC
** Usage
*** Option 1
- Open file "/usr/local/share/info/sicp.info" in emacs.
- emacs will open it in info mode.
*** Option 2
- "C-h i"
- This will open info InfoMode, search for SICP.
